from collections import defaultdict, deque
from itertools import imap, ifilter, product

__author__ = 'nhc'


class Expression(object):
    """
    Abstract superclass of all Expressions.
    Defines operators that work on Expressions.
    """
    def all_dicts(self):
        """
        Must be overridden by all subclasses.
        """
        raise NotImplementedError

    def __and__(self, other):
        """
        :returns An AndExpression combining self and other.
        """
        return AndExpression(self, other)

    def __or__(self, other):
        """
        :returns An OrExpression combining self and other.
        """
        return OrExpression(self, other)


class ConstantExpression(Expression):
    """
    An Expression generating exactly one dict.
    """
    def __init__(self, d):
        """
        Verifies that d is a dict and stores a copy of d.
        :param d: The single dict to be generated by this Expression.
        """
        assert isinstance(d, dict)
        self.d = d.copy()

    def all_dicts(self):
        """
        :returns A generator yielding a copy of the stored dict.
        """
        yield self.d.copy()

    def __repr__(self):
        return '{}({!r})'.format(self.__class__.__name__, self.d)


def when(**kwargs):
    """
    Syntactic sugar for a ConstantExpression. Example: when(a=0, b=1).
    :param kwargs: Any dict.
    :return: A ConstantExpression yielding the given kwargs.
    """
    return ConstantExpression(kwargs)


class AggregateExpression(Expression):
    """
    An aggregate Expression, i.e. one that combines subexpressions.
    This is an abstract superclass of OrExpression and AndExpression.
    """
    def __init__(self, *subexpressions):
        """
        Stores the given subexpressions after verifying that each is
        an Expression instance.
        :param subexpressions: The subexpression to aggregate.
        """
        for subexpression in subexpressions:
            assert isinstance(subexpression, Expression)
        self.subexpressions = subexpressions

    def all_dicts(self):
        """
        Override this in subclasses.
        """
        raise NotImplementedError

    def __repr__(self):
        return '{}{!r}'.format(self.__class__.__name__, self.subexpressions)


class AndExpression(AggregateExpression):
    """
    An aggregate Expression which generates one dict for each combination
    of dicts from its subexpressions when these are compatible (i.e.
    do not define different values for the same key).
    """
    def all_dicts(self):
        """
        Yields a number of dicts based on this object's subexpressions.
        """
        dict_generators = (sub_expr.all_dicts() for sub_expr in self.subexpressions)
        for prod in product(*dict_generators):
            try:
                yield AndExpression.union(prod)
            except AssertionError:
                pass

    @staticmethod
    def union(dicts):
        """
        :param dicts A tuple or list of dicts, e.g. ({0: 1},{'a':'b'}).
        :return The union of the dicts, e.g. {'a': 'b', 0: 1}.
        :raises AssertionError if two dicts defined different values for
        the same key.
        """
        assert len(dicts) > 0
        accumulator = defaultdict(set)
        for d in dicts:
            for key in d:
                accumulator[key].add(d[key])
        result = dict()
        for key, value_set in accumulator.iteritems():
            assert len(value_set) == 1
            result[key] = value_set.pop()
        return result


class OrExpression(AggregateExpression):
    """
    An aggregate Expression which generates every dict
     generated by its subexpressions.
    """
    def all_dicts(self):
        """
        Yields all dicts generated by this object's subexpressions.
        """
        iterables = [e.all_dicts() for e in self.subexpressions]
        return OrExpression.round_robin(*iterables)

    @staticmethod
    def round_robin(*iterables):
        """Splices the given iterables fairly, see
           http://bugs.python.org/issue1757395
        """
        pending = deque(iter(i).next for i in reversed(iterables))
        rotate, pop, _StopIteration = pending.rotate, pending.pop, StopIteration
        while pending:
            try:
                while 1:
                    yield pending[-1]()
                    rotate()
            except _StopIteration:
                pop()


class ReferenceExpression(Expression):
    """
    An Expression which refers to another Expression and generates
    exactly the dicts that the referred Expression does.
    The reference can be updated many times.
    """
    def __init__(self):
        """
        Sets the internal reference to None.
        set_expression() must be called before all_dicts() or
        the latter will fail.
        """
        self.ref = None

    def set_expression(self, ref):
        """
        Sets the internal reference.
        :param ref: The Expression to refer to.
        :raises: AssertionError if ref is not an Expression.
        """
        assert isinstance(ref, Expression)
        self.ref = ref

    def all_dicts(self):
        """
        :return: The dict generator from the referred Expression.
        :raises AssertionError: if the internal reference is None.
        """
        assert self.ref is not None
        return self.ref.all_dicts()

    def __repr__(self):
        return '<{}{!r}>'.format(self.__class__.__name__, self.ref)


class FilterEqExpression(Expression):
    """
    An Expression that generates every dict generated by its subexpression
    exception the ones where a specified key does not map to a specified value.
    """
    def __init__(self, key, expected_value, expr):
        """
        The return Expression will propagate every dict d from expr,
        if d[key] == expected_value
        :param key: The key to check, e.g. 'x'
        :param expected_value: The value that key must map to, e.g. 42
        :param expr: The expression generated the dicts to check
        :return: A filtered Expression
        """
        self.key = key
        self.expected_value = expected_value
        assert isinstance(expr, Expression)
        self.expr = expr

    def all_dicts(self):
        """
        Yields every dict generated by this object's subexpression,
        if that dict passes the specified filter
        """
        for d in self.expr.all_dicts():
            if d[self.key] == self.expected_value:
                yield d


class RenameExpression(Expression):
    """
    An Expression the generates at most one dict per dict generated
    by its subexpression.
    For example, RenameExpression(when(x=0), x='a') generates
      {'a': 0}
    i.e. the 'x' key is renamed to 'a'.
    When there is a clash between the two values for the same new key, e.g.
      RenameExpression(when(x=0, y=1), x='a', y='a')
    no dict is generated, but the process continues, so e.g.
      RenameExpression(when(x=0, y=1) | when(x=0, y=0), x='a', y='a')
    generates one dict:
      {'a': 0}
    """
    def __init__(self, expr, **old_key_to_new_key):
        """
        :param expr: Subexpression, e.g. when(x=0)
        :param old_key_to_new_key: Map fom "old" keys generated by the subexpression
        to "new" keys generated by the returned expression.
        """
        assert isinstance(expr, Expression)
        self.expr = expr
        self.map = old_key_to_new_key

    def all_dicts(self):
        """
        :return: Yields one renamed dict per dict genereated by the subexpression,
        but only if there are no clashes.
        """
        for d in self.expr.all_dicts():
            if len(self.map) == 0:
                yield {}
            else:
                try:
                    dicts = [{new_key: d[old_key]} for old_key, new_key in self.map.iteritems()]
                    yield AndExpression.union(dicts)
                except AssertionError:
                    pass
